#!/usr/bin/perl

# Generate parser for SCAMP assembler, based on instructions from instructions.json
#
# Most of the instruction text needs to exactly match, with "Char" or "String"
# "i8l" and "i8h" have to be constants in 0x0000..0x00ff and 0xff00..0xffff
# "i16" can be any constant, or a label
#
# TODO: [nice] Whitespace just turns into "skip()"?
# TODO: [perf] generate more efficient code!
# TODO: [bug] can't parse "ret i8l" because bare "ret" matches first
# TODO: [bug] can't parse "sb r254, ..." because "r254" isn't literally "(65534)"

use strict;
use warnings;

use JSON qw(decode_json);
use FindBin;

my $instructions = load_instructions();

print parser_header() . "\n";

my %mnemonic;
my %argparser;
my $argparsernum = 0;

for my $instr (keys %$instructions) {
    my $opcode = $instructions->{$instr}{opcode};

    my ($mnem, $args) = split / /, $instr, 2;
    push @{ $mnemonic{$mnem} }, [ $args||'', $opcode, $instructions->{$instr}{cycles} ];
};

for my $mnem (keys %mnemonic) {
    print mkparser($mnem, @{ $mnemonic{$mnem} }) . "\n";
}

print parser_footer() . "\n";

sub mkargparser {
    my ($args, $opcode) = @_;

    return '' if $argparser{$args};

    my $name = "Instr_" . $args . "_" . $argparsernum++;
    $name =~ s/\+/p/g;
    $name =~ s/\-/m/g;
    $name =~ s/[^a-zA-Z0-9]/_/g;
    $name =~ s/_+/_/g;

    $argparser{$args} = $name;

    my $src = '';

    $src .= "# $args\n";
    $src .= "var $name = func(opcode) {\n";

    my $i16 = 0;
    my $i8 = 0;

    my $str = '';

    while ($args =~ /(i8l|i8h|i16|\(i8h\)|\(i16\)|.)/g) {
        my $bit = $1;
        if ($bit =~ /(i8l|i8h|i16|\(i8h\)|\(i16\))/) {
            if ($str) {
                if (length($str) == 1) {
                    $src .= "    if (!parse(Char,'$str')) return 0;\n";
                } else {
                    $src .= "    if (!parse(String,\"$str\")) return 0;\n";
                }
                $str = '';
            }

            if ($bit eq 'i8l') {
                $i8 = 1;
                $src .= "    if (!parse(I8l,0)) return 0;\n";
            } elsif ($bit eq 'i8h') {
                $i8 = 1;
                $src .= "    if (!parse(I8h,0)) return 0;\n";
            } elsif ($bit eq 'i16') {
                $i16 = 1;
                $src .= "    if (!parse(I16,0)) return 0;\n";
            } elsif ($bit eq '(i8h)') {
                $i8 = 1;
                $src .= "    if (!parse(Indirection,8)) return 0;\n";
            } elsif ($bit eq '(i16)') {
                $i16 = 1;
                $src .= "    if (!parse(Indirection,16)) return 0;\n";
            } else {
                die "unrecognised bit: $bit";
            }
        } else {
            $str .= $bit;
        }
    }

    if ($str) {
        $src .= "    if (!parse(String,\"$str\")) return 0;\n";
    }

    $src .= "    skip();\n";

    if ($i8) {
        $src .= "    emit(opcode | asm_i8);\n";
    } else {
        $src .= "    emit(opcode);\n";
    }

    if ($i16) {
        $src .= "    emit_i16();\n";
    }

    $src .= "    return 1;\n";
    $src .= "};\n";

    return $src;
}

sub argparser {
    my ($args) = @_;
    return $argparser{$args}||die "no parser for: $args";
}

sub mkparser {
    my ($mnem, @instrs) = @_;

    my $src = '';

    # for ambiguous instructions, try the fastest ones first
    @instrs = sort { $a->[2] <=> $b->[2] } @instrs;

    for my $mode (@instrs) {
        my ($instr, $opcode, $cycles) = @$mode;
        $src .= mkargparser($instr, $opcode);
    }

    $src .= "var Instr_".safemnem($mnem)." = func(x) {\n";
    $src .= "    if (!parse(Keyword,\"$mnem\")) return 0;\n";
    for my $mode (@instrs) {
        my ($instr, $opcode, $cycles) = @$mode;
        $src .= "    if (parse(" . argparser($instr) . ",0x".sprintf("%04x",$opcode<<8).")) return 1;\n";
    }
    $src .= "    die(\"illegal $mnem instruction\",0);\n";
    $src .= "};\n";

    return $src;
}

sub parser_header {
    my $src = '';

    $src .= "# generated by mk-asm-parser " . gmtime() . "\n";
    $src .= "\n";
    $src .= "include \"parse.sl\";\n";
    $src .= "\n";

    $src .= "var I8l;\n";
    $src .= "var I8h;\n";
    $src .= "var I16;\n";
    $src .= "var Indirection;\n";
    $src .= "var emit;\n";
    $src .= "var emit_i16;\n";
    $src .= "var asm_i8;\n";

    return $src;
}

sub parser_footer {
    my $src = '';

    $src .= "var Instr = func(x) {\n";
    $src .= "    skip();\n";

    for my $mnem (keys %mnemonic) {
        $src .= "    if (parse(Instr_".safemnem($mnem).",0)) return 1;\n";
    }

    $src .= "    return 0;\n";
    $src .= "};\n";

    return $src;
}

sub safemnem {
    my ($mnem) = @_;

    # make a copy of $mnem safe for use in identifiers
    my $safemnem = $mnem;
    $safemnem =~ s/\+/plus/g;
    $safemnem =~ s/\-/minus/g;

    return $safemnem;
}

sub load_instructions {
    my $file = $FindBin::Bin . "/instructions.json";
    open(my $fh, '<', $file)
        or die "can't read $file: $!";
    my $c = join('', <$fh>);
    close $fh;
    return decode_json($c);
}
