#!/usr/bin/perl

# Generate parser for SCAMP assembler, based on instructions from instructions.json
#
# Most of the instruction text needs to exactly match, with "Char" or "String"
# "i8l" and "i8h" have to be constants in 0x0000..0x00ff and 0xff00..0xffff
# "i16" can be any constant, or a label
#
# TODO: [mem] instead of writing SLANG code with [] arrays, write asm code instead so that
#       we don't waste a load of memory on initialising the arrays
# TODO: [bug] the problem with this is that it references "IndirectionEquals" etc. by name
#       before such a time that those functions are initialised; we need to come up with a
#       way either for asm.sl to initialise them before including asmparser.sl, or else
#       to not use them until after they're initialised

use strict;
use warnings;

use JSON qw(decode_json);
use FindBin;

my $instructions = load_instructions();

print parser_header() . "\n";

my %mnemonic;
my %argparser;
my $argparsernum = 0;

my %interned;
my $internlabel = 0;

for my $instr (sort keys %$instructions) {
    my $opcode = $instructions->{$instr}{opcode};

    my ($mnem, $args) = split / /, $instr, 2;
    push @{ $mnemonic{$mnem} }, [ $args||'', $opcode, $instructions->{$instr}{cycles} ];
};

for my $mnem (sort keys %mnemonic) {
    print mkparser($mnem, @{ $mnemonic{$mnem} }) . "\n";
}

print parser_footer() . "\n";

sub mkargparser {
    my ($args) = @_;

    return '' if $argparser{$args};

    my $name = "Instr_" . $args . "_" . $argparsernum++;
    $name =~ s/\+/p/g;
    $name =~ s/\-/m/g;
    $name =~ s/[^a-zA-Z0-9]/_/g;
    $name =~ s/_+/_/g;

    $argparser{$args} = $name;

    my $src = '';

    $src .= "# $args\n";
    $src .= "var $name = asm {\n";

    my $i16 = 0;
    my $i8 = 0;

    my $str = '';

    my @parts;
    while ($args =~ /(i8l|i8h|i16|\(i8h\)|\(i16\)|\(\d+\)|.)/g) {
        my $bit = $1;
        if ($bit =~ /i8l|i8h|i16|\(i8h\)|\(i16\)|\(\d+\)/) {
            if ($str) {
                if (length($str) == 1) {
                    push @parts, "    .word myChar\n    .word " . sprintf("0x%02x", ord($str)) . "\n";
                } else {
                    push @parts, "    .word myString\n    .word " . intern($str) . "\n";
                }
                $str = '';
            }

            if ($bit eq 'i8l') {
                $i8 = 1;
                push @parts, "    .word myI8l\n    .word 0\n";
            } elsif ($bit eq 'i8h') {
                $i8 = 1;
                push @parts, "    .word myI8h\n    .word 0\n";
            } elsif ($bit eq 'i16') {
                $i16 = 1;
                push @parts, "    .word myI16\n    .word 0\n";
            } elsif ($bit eq '(i8h)') {
                $i8 = 1;
                push @parts, "    .word myIndirection\n    .word 8\n";
            } elsif ($bit eq '(i16)') {
                $i16 = 1;
                push @parts, "    .word myIndirection\n    .word 16\n";
            } elsif ($bit =~ /^\(\d+\)$/) {
                # indirection on a constant - abuse Indirection(16)
                $bit =~ /(\d+)/;
                my $val = $1;
                push @parts, "    .word myIndirectionEquals\n    .word $val\n";
            } else {
                die "unrecognised bit: $bit";
            }
        } else {
            $str .= $bit;
        }
    }
    if ($str) {
        if (length($str) == 1) {
            push @parts, "    .word myChar\n    .word " . sprintf("0x%02x", ord($str)) . "\n";
        } else {
            push @parts, "    .word myString\n    .word " . intern($str) . "\n";
        }
    }

    my $emit_val = 0;
    $emit_val |= 1 if $i8;
    $emit_val |= 2 if $i16;
    $src .= "    .word $emit_val,\n";

    $src .= join("", @parts);

    $src .= "    .word 0\n";
    $src .= "};\n";

    return $src;
}

sub argparser {
    my ($args) = @_;
    return $argparser{$args}||die "no parser for: $args";
}

sub mkparser {
    my ($mnem, @instrs) = @_;

    my $src = '';

    # for ambiguous instructions, try the fastest ones first
    @instrs = sort { $a->[2] <=> $b->[2] } @instrs;

    for my $mode (@instrs) {
        my ($instr, $opcode, $cycles) = @$mode;
        $src .= mkargparser($instr);
    }

    $src .= "var Instr_".safemnem($mnem)." = [\n";
    $src .= "    \"$mnem\",\n";
    for my $mode (@instrs) {
        my ($instr, $opcode, $cycles) = @$mode;
        $src .= "    " . argparser($instr) . "," . sprintf("0x%04x",$opcode<<8) . ",\n";
    }
    $src .= "];\n";

    return $src;
}

sub parser_header {
    my $src = '';

    $src .= "# generated by mk-asm-parser " . gmtime() . "\n";
    $src .= "\n";
    $src .= "include \"parse.sl\";\n";
    $src .= "\n";

    $src .= "var I8l;\n";
    $src .= "var I8h;\n";
    $src .= "var I16;\n";
    $src .= "var Indirection;\n";
    $src .= "var IndirectionEquals;\n";
    $src .= "var Instr_args;\n";
    $src .= "var Instr_anyargs;\n";
    $src .= "var emit;\n";
    $src .= "var emit_i16;\n";
    $src .= "var asm_i8;\n";
    $src .= "var asm_i16;\n";
    $src .= "var i16_identifier;\n";
    $src .= "var opcode;\n";

    # TODO: [perf] find a way to avoid the indirect function call
    $src .= "asm {\n";
    for my $func (qw(Char String I8l I8h I16 Indirection IndirectionEquals)) {
        $src .= "my$func: jmp (_$func)\n";
    }
    $src .= "};\n";

    return $src;
}

sub parser_footer {
    my $src = '';

    $src .= "var Instr = func(x) {\n";
    $src .= "    skip();\n";
    $src .= "    var ch = peekchar();\n";

    my $group = '';
    for my $mnem (sort keys %mnemonic) {
        my $ch = substr($mnem, 0, 1);
        if ($ch ne $group) {
            $src .= "    } else\n" if $group;
            $src .= "    if (ch == '$ch') {\n";
            $group = $ch;
        }
        $src .= "        if (parse(Instr_anyargs,Instr_".safemnem($mnem).")) return 1;\n";
    }

    $src .= "    };\n" if $group;

    $src .= "    return 0;\n";
    $src .= "};\n\n";

    $src .= "asm {\n";
    for my $str (sort { $interned{$a} cmp $interned{$b} } keys %interned) {
        $src .= "$interned{$str}: .str \"$str\0\"\n";
    }
    $src .= "};\n";

    return $src;
}

sub intern {
    my ($str) = @_;

    $interned{$str} //= "str" . ($internlabel++);

    return $interned{$str};
}

sub safemnem {
    my ($mnem) = @_;

    # make a copy of $mnem safe for use in identifiers
    my $safemnem = $mnem;
    $safemnem =~ s/\+/plus/g;
    $safemnem =~ s/\-/minus/g;

    return $safemnem;
}

sub load_instructions {
    my $file = $FindBin::Bin . "/instructions.json";
    open(my $fh, '<', $file)
        or die "can't read $file: $!";
    my $c = join('', <$fh>);
    close $fh;
    return decode_json($c);
}
