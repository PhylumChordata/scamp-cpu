#!/usr/bin/perl

# Generate parser for SCAMP assembler, based on instructions from instructions.json
#
# Most of the instruction text needs to exactly match, with "Char" or "String"
# "i8l" and "i8h" have to be constants in 0x0000..0x00ff and 0xff00..0xffff
# "i16" can be any constant, or a label
#
# TODO: [nice] Whitespace just turns into "skip()"?
# TODO: [perf] generate more efficient code!

use strict;
use warnings;

use JSON qw(decode_json);
use FindBin;

my $instructions = load_instructions();

print parser_header() . "\n";

my %mnemonic;

for my $instr (keys %$instructions) {
    my $opcode = $instructions->{$instr}{opcode};

    my ($mnem, $args) = split / /, $instr, 2;
    push @{ $mnemonic{$mnem} }, [ $args||'', $opcode, $instructions->{$instr}{cycles} ];
};

for my $mnem (keys %mnemonic) {
    print mkparser($mnem, @{ $mnemonic{$mnem} }) . "\n";
}

print parser_footer() . "\n";

sub mkparser {
    my ($mnem, @instrs) = @_;

    my $src = '';

    # for ambiguous instructions, try the fastest ones first
    @instrs = sort { $a->[2] <=> $b->[2] } @instrs;

    for my $mode (@instrs) {
        my ($instr, $opcode, $cycles) = @$mode;
        $src .= "# $mnem $instr\n";
        $src .= "var Instr_".safemnem($mnem)."_$opcode = func(x) {\n";

        my $i16 = 0;
        my $i8 = 0;

        my $str = '';

        while ($instr =~ /(i8l|i8h|i16|\(i8h\)|.)/g) {
            my $bit = $1;
            if ($bit =~ /(i8l|i8h|i16|\(i8h\))/) {
                if ($str) {
                    if (length($str) == 1) {
                        $src .= "    if (!parse(Char,'$str')) return 0;\n";
                    } else {
                        $src .= "    if (!parse(String,\"$str\")) return 0;\n";
                    }
                    $str = '';
                }

                if ($bit eq 'i8l') {
                    $i8 = 1;
                    $src .= "    if (!parse(I8l,0)) return 0;\n";
                } elsif ($bit eq 'i8h') {
                    $i8 = 1;
                    $src .= "    if (!parse(I8h,0)) return 0;\n";
                } elsif ($bit eq 'i16') {
                    $i16 = 1;
                    $src .= "    if (!parse(I16,0)) return 0;\n";
                } elsif ($bit eq '(i8h)') {
                    $i8 = 1;
                    $src .= "    if (!parse(Pseudoreg,0)) return 0;\n";
                } else {
                    die "unrecognised bit: $bit";
                }
            } else {
                $str .= $bit;
            }
        }

        if ($str) {
            $src .= "    if (!parse(String,\"$str\")) return 0;\n";
        }

        $src .= "    skip();\n";

        if ($i8) {
            $src .= "    emit(0x" . sprintf("%04x",($opcode<<8)) . " | asm_i8);\n";
        } else {
            $src .= "    emit(0x" . sprintf("%04x",($opcode<<8)) . ");\n";
        }

        if ($i16) {
            $src .= "    emit_i16();\n";
        }

        $src .= "    return 1;\n";
        $src .= "};\n";
    }

    $src .= "var Instr_".safemnem($mnem)." = func(x) {\n";
    $src .= "    if (!parse(Keyword,\"$mnem\")) return 0;\n";
    $src .= "    if (parse(Instr_".safemnem($mnem)."_$_,0)) return 1;\n" for map { $_->[1] } @instrs;
    $src .= "    die(\"illegal $mnem instruction\",0);\n";
    $src .= "};\n";

    return $src;
}

sub parser_header {
    my $src = '';

    $src .= "# generated by mk-asm-parser " . gmtime() . "\n";
    $src .= "\n";
    $src .= "include \"parse.sl\";\n";
    $src .= "\n";

    $src .= "var I8l;\n";
    $src .= "var I8h;\n";
    $src .= "var I16;\n";
    $src .= "var Pseudoreg;\n";
    $src .= "var emit;\n";
    $src .= "var emit_i16;\n";
    $src .= "var asm_i8;\n";

    return $src;
}

sub parser_footer {
    my $src = '';

    $src .= "var Instr = func(x) {\n";

    for my $mnem (keys %mnemonic) {
        $src .= "    if (parse(Instr_".safemnem($mnem).",0)) return 1;\n";
    }

    $src .= "    return 0;\n";
    $src .= "};\n";

    return $src;
}

sub safemnem {
    my ($mnem) = @_;

    # make a copy of $mnem safe for use in identifiers
    my $safemnem = $mnem;
    $safemnem =~ s/\+/plus/g;
    $safemnem =~ s/\-/minus/g;

    return $safemnem;
}

sub load_instructions {
    my $file = $FindBin::Bin . "/instructions.json";
    open(my $fh, '<', $file)
        or die "can't read $file: $!";
    my $c = join('', <$fh>);
    close $fh;
    return decode_json($c);
}
