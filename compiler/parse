#!/usr/bin/perl

use strict;
use warnings;

use List::Util qw(any);

my $s = join('',<>);
my @s = split //, $s;
my $pos = 0;
my $line = 1;
my $col = 1;
my $labelnum = 0;

my $scope = {
    global => 1,
    symbols => {},
    parent => undef,
};

my @stack;

parseProgram();
if ($pos != @s) {
    print "Ended at $pos (line $line, col $col): had " . (@s-$pos) . " chars left over\n";
}

# recursive descent parser based on https://www.youtube.com/watch?v=Ytq0GQdnChg
# each parseFoo() parses a rule from the grammar:
#  - if it matches, return true and $pos points at the next character in the input
#  - if it doesn't match, return false and leave $pos unchanged
#
# TODO: get out of manually restoring $pos, make something do it for us
# TODO: restore line/col when pos is restored
# TODO: some tracing of call stack for debugging
# TODO: only skip() after terminals
# TODO: order the disjunctions so that the most-specific ones come first (i.e. don't let keywords
#       match as identifiers in expressions if we can unambiguously identify them as their actual
#       keyword)
# TODO: annotate generated assembly code with the source code that generated it
# TODO: emit code via a helper that performs peephole optimisation
# TODO: warn if we know a function has been called with the wrong number of arguments

sub parseProgram {
    return 0 if !parseStatements();

    die "expected to be left in global scope after program" if !$scope->{global};

    # allocate space for globals
    for my $global (keys %{ $scope->{symbols} }) {
        print "_$global: .word 0 # global\n" if !$scope->{symbols}{$global}{extern};
    }

    return 1;
}

sub parseStatements {
    while (1) {
        skip();
        return 1 if !parseStatement();
        skip();
        return 1 if !parseChar(';');
    }
}

sub parseStatement {
    return 1 if parseBlock() || parseExtern() || parseDeclaration() || parseConditional() || parseLoop() || parseReturn() || parseAssignment();
    if (parseExpression()) {
        # discard the value of the expression
        print "# discard expression value\n";
        print "pop x\n";
        return 1;
    }
    return 0;
}

# create new nested scope
sub parseBlock {
    return 0 if !parseChar('{');
    skip();

    # TODO: make blocks start/end scopes, alternatively disallow variable declarations inside nested blocks
    #newscope();

    parseStatements() && skip();

    die "block must end with }" if !parseChar('}');
    skip();

    #endscope();

    return 1;
}

sub newscope {
    # save old base pointer, and put new base pointer in r253
    print "# newscope:\n";
    print "ld x, r253\n";
    print "push x\n";
    print "ld r253, sp\n";

    $scope = {
        symbols => {},
        parent => $scope,
        bp_rel => 0,
        params => 0,
    };
}

sub endscope {
    die "can't exit global scope" if $scope->{global};

    runtime_endscope();

    $scope = $scope->{parent};
}

sub runtime_endscope {
    # restore old sp and bp
    print "# endscope: \n";
    print "ld sp, r253\n";
    print "pop x\n";
    print "ld r253, x\n";
}

# add name to current scope (possibly global)
sub parseDeclaration {
    return 0 if !parseString('var');
    skip();
    die "var declaration needs identifier" if !parseIdentifier();
    skip();
    my $id = pop @stack;
    die "var declaration expected identifier" if $id->{type} ne 'identifier';

    die "duplicate declaration in scope: $id->{name}" if $scope->{symbols}{$id->{name}};

    # add name to scope
    $scope->{symbols}{$id->{name}} = {
        type => $scope->{global} ? 'global' : 'local',
        bp_rel => $scope->{bp_rel}--,
    };

    if (!$scope->{global}) {
        print "# allocate space for $id->{name}\n";
        print "dec sp\n";
    }

    return 1 if !parseChar('=');
    skip();

    # now an expression to initialise the variable
    parseExpression();
    skip();

    poptovar($id->{name});
    return 1;
}

sub symlookup {
    my ($name) = @_;

    my $s = $scope;

    while ($s) {
        return $s->{symbols}{$name} if $s->{symbols}{$name};
        $s = $s->{parent};
    }
}

# add name to global scope, but don't allocate any space for it
sub parseExtern {
    return 0 if !parseString('extern');
    skip();

    if (!parseIdentifier()) {
        die "extern expects identifier\n";
    }
    skip();

    my $id = pop @stack;
    die "expected identifier" if $id->{type} ne 'identifier';

    die "can only add extern in global scope" if !$scope->{global};
    $scope->{symbols}{$id->{name}} = {
        type => 'global',
        extern => 1,
    };

    return 1;
}

# stack will have rvalue at top and lvalue below.
# pop lvalue into r0
# pop rvalue into r1
# generate: ld (r1), r0
sub parseAssignment {
    my $pos0 = $pos;
    if (!(parseLValue() && skip() && parseChar('='))) {
        $pos = $pos0;
        return 0;
    }

    my $lval = pop @stack;

    if ($lval->{type} eq 'pointer') {
        # leave the pointer on the stack
        print "# ... leave pointer on stack ...\n";
    } elsif ($lval->{type} ne 'identifier') {
        die "unexpected lvalue type: $lval->{type}";
    }

    skip();
    die "assignment needs rvalue" if !parseExpression();
    skip();

    if ($lval->{type} eq 'pointer') {
        print "# store to pointer:\n";
        print "pop x # value\n";
        print "ld r0, x\n";
        print "pop x # pointer\n";
        print "ld (x), r0\n";
    } elsif ($lval->{type} eq 'identifier') {
        poptovar($lval->{name});
    } else {
        die "unexpected lvalue type: $lval->{type}";
    }

    return 1;
}

# push address of lvalue onto stack
# globals: easy
# locals: ???
# maybe we say all declarations in a scope have to come before all statements
sub parseLValue {
    my $pos0 = $pos;
    return 1 if parseIdentifier();
    if (!parseChar('*')) {
        $pos = $pos0;
        return 0;
    }
    if (parseExpression()) {
        push @stack, {
            type => 'pointer',
        };
        return 1;
    }
    $pos = $pos0;
    return 0;
}

# after parseExpression, branch to elselabel if false, then let parseStatement
# generate its code followed by a jump to the endiflabel, then put the elselabel,
# and if there's an "else" then let another parseStatement generate its code, then put the endiflabel
sub parseConditional {
    my $pos0 = $pos;
    return 0 if !parseString("if");
    skip();

    my $falselabel = label();

    die "if condition needs open paren" if !parseChar("(");
    skip();

    print "# if condition\n";
    die "if condition needs expression" if !parseExpression();
    skip();

    # if top of stack is 0, jmp $falselabel
    print "pop x\n";
    print "test x\n";
    print "jz $falselabel\n";

    die "if condition needs close paren" if !parseChar(")");
    skip();

    print "# if body\n";
    die "if needs body" if !parseStatement();
    skip();

    if (parseString("else")) {
        skip();

        my $endiflabel = label();
        print "jmp $endiflabel\n";

        print "# else body\n";
        print "$falselabel:\n";

        die "else needs body" if !parseStatement();
        skip();

        print "$endiflabel:\n";
    } else {
        print "$falselabel:\n";
    }

    return 1;
}

# write a looplabel, then after parseExpression branch to endwhilelabel if false, then let
# parseStatement write its code, then jump to looplabel
sub parseLoop {
    return 0 if !parseString('while');
    skip();

    die "while condition needs to start with paren" if !parseChar('(');
    skip();

    my $loop = label();
    my $endloop = label();

    print "# while loop\n";
    print "$loop:\n";
    die "while loop needs expression" if !parseExpression();
    skip();

    # if top of stack is 0, jmp $endloop
    print "pop x\n";
    print "test x\n";
    print "jz $endloop\n";

    die "while condition needs to end with paren" if !parseChar(')');
    skip();

    die "while loop needs body" if !parseStatement();
    skip();

    print "jmp $loop\n";
    print "$endloop:\n";

    return 1;
}

# end however many scopes we're in
# pop args off stack and 'ret'
sub parseReturn {
    return 0 if !parseString("return");
    skip();

    die "must return something" if !parseExpression();
    skip();

    # we currently have the return value on the stack, we want to pop it to r0
    print "# return\n";
    print "pop x\n";
    print "ld r0, x\n";

    # then clean up however many scopes we've started since opening the function, leaving the
    # stack pointer where it was when we were called
    my $s = $scope;
    runtime_endscope();
    while (!$s->{funcdecl}) {
        runtime_endscope();
        $s = $s->{parent};
    }

    # then clean up the function parameters
    print "# function had $s->{params} parameters:\n";
    print "add sp, $s->{params}\n";

    # then return to the caller
    print "ret\n";

    return 1;
}

sub parseConstant {
    return parseNumericLiteral() || parseStringLiteral() || parseFunctionDeclaration();
}

sub parseNumericLiteral {
    return parseHexLiteral() || parseBinaryLiteral() || parseCharacterLiteral() || parseDecimalLiteral();
}

sub parseHexLiteral {
    return 0 if !parseString("0x");
    my $pos0 = $pos;
    if (!matchChar(qr/[0-9a-fA-F]/)) {
        die "illegal hex literal\n";
    }
    while (matchChar(qr/[0-9a-fA-F]/)) { }

    my $val = substr($s, $pos0, $pos-$pos0);
    genliteral(hex($val));

    skip();
    return 1;
}

sub parseBinaryLiteral {
    return 0 if !parseString("0b");
    my $pos0 = $pos;
    if (!matchChar(qr/[01]/)) {
        die "illegal binary literal\n";
    }
    while (matchChar(qr/[01]/)) { }

    my $val = substr($s, $pos0, $pos-$pos0);
    genliteral(oct("0b$val"));

    skip();
    return 1;
}

sub parseCharacterLiteral {
    my $pos0 = $pos;
    return 0 if !parseChar("'");
    my $c = $s[$pos++];
    if ($c eq '\\') {
        genliteral(ord(escapedchar($s[$pos])));
        $pos++;
    } else {
        genliteral(ord($c));
    }
    
    return 1 if parseChar("'");
    die "illegal character literal\n";
    $pos = $pos0;
    return 0;
}

sub parseDecimalLiteral {
    my $pos0 = $pos;
    return 0 if !matchChar(qr/[-+0-9]/);
    while (matchChar(qr/\d/)) {}

    my $val = substr($s, $pos0, $pos-$pos0);
    genliteral($val);

    skip();
    return 1;
}

sub genliteral {
    my ($val) = @_;

    print "# genliteral:\n";

    $val += 0x10000 if $val < 0; # make everything positive

    die "numeric literal out of range: $val\n" if $val < 0 || $val > 0xffff;

    if ($val <= 0x00ff || $val >= 0xff00) {
        print "push $val\n";
    } else {
        print "ld x, $val\n";
        print "push x\n";
    }
}

# write a jump to endofstringlabel, write the string, write the endofstringlabel
sub parseStringLiteral {
    return 0 if !parseChar('"');
    my $startstring = label();
    my $endstring = label();

    # XXX: generate string in-line
    # TODO: add it to a table of string constants and write them at the end of the program

    print "# parseStringLiteral:\n";

    print "jmp $endstring\n";
    print "$startstring:\n";
    while ($pos < @s) {
        if (parseChar('"')) {
            skip();

            print ".word 0\n"; # terminate
            print "$endstring:\n";
            print "ld x, $startstring\n";
            print "push x\n";
            return 1;
        }
        if (parseChar('\\')) {
            print ".word " . ord(escapedchar($s[$pos])) . "\n";
        } else {
            print ".word " . ord($s[$pos]) . "\n";
        }
        $pos++;
    }
    die "un-terminated string literal (started at line ... col ...)\n";
}

# n => "\n", r => "\r", etc.
sub escapedchar {
    my ($c) = @_;

    my %map = (
        n => "\n",
        r => "\r",
        t => "\r",
        0 => "\0",
        "]" => "\]",
    );

    return $map{$c}||$c;
}

sub parseFunctionDeclaration {
    return 0 if !parseString('func');
    skip();

    die "can only declare functions in global scope" if !$scope->{global};

    print "\n# parseFunctionDeclaration:\n";

    die "expected (" if !parseChar('(');
    skip();

    my $sp0 = @stack;
    parseParameters();
    skip();

    my $functionlabel = label();
    my $functionend = label();

    print "jmp $functionend\n";
    print "$functionlabel:\n";

    newscope();

    $scope->{funcdecl} = 1;

    my $bp_rel = 2;

    while (@stack != $sp0) {
        my $id = pop @stack;
        die "expected identified" if $id->{type} ne 'identifier';
        die "duplicate parameter name: $id->{name}" if $scope->{symbols}{$id->{name}};
        $scope->{symbols}{$id->{name}} = {
            type => 'local',
            bp_rel => $bp_rel++, # parameters are above the base pointer, locals are below the base pointer
        };
        $scope->{params}++;
    }

    die "expected )" if !parseChar(')');
    skip();

    parseStatement();
    skip();
    endscope();

    # implicit "return 0"
    # TODO: use the code for parseReturn() instead; this version is broken
    print "push 0\n";
    print "ret\n";
    print "# end function declaration\n\n";

    print "$functionend:\n";
    print "ld x, $functionlabel\n";
    print "push x\n";

    return 1;
}

# somehow return a list of the parameter names to parseFunctionDeclaration()
sub parseParameters {
    while (1) {
        skip();
        return 1 if !parseIdentifier();
        skip();
        return 1 if !parseChar(',');
    }
}

sub parseFunctionCall {
    my $pos0 = $pos;
    my $sp0 = @stack;
    if (parseIdentifier() && skip() # TODO: allow "expression" instead of "identifier"
        && parseChar('(') && skip()) {
        print "# parseFunctionCall:\n";
        # backup return address before we push arguments
        print "ld x, r254\n";
        print "push x\n";

        if (parseArguments() && skip()
            && parseChar(')') && skip()) {
            my $id = $stack[$sp0];
            die "identifier type != identifier" if $id->{type} ne 'identifier';

            # call function
            pushvar($id->{name}); # XXX: when we parseExpression() instead of parseIdentifier(), this push will happen automatically
            print "pop x\n";
            print "call x\n";

            # restore return address
            print "pop x\n";
            print "ld r254, x\n";

            # push return value
            print "ld x, r0\n";
            print "push x\n";

            pop @stack while @stack > $sp0;
            return 1;
        } else {
            die "illegal function call\n";
        }
    }
    $pos = $pos0;
    return 0;
}

sub parseArguments {
    while (1) {
        skip();
        return 1 if !parseExpression();
        skip();
        return 1 if !parseChar(',');
    }
}

sub parseUnaryExpression {
    my $op = $s[$pos];
    return 0 if !matchChar(qr/[!~*+-]/);
    skip();
    if (!parseExpression()) {
        die "unary operator $op must be followed by an expression";
    }

    if ($op eq '~') {
        # pop arg from stack, negate it, put it back on stack
        print "# unary bitwise complement:\n";
        print "pop x\n";
        print "not x\n";
        print "push x\n";
    } elsif ($op eq '!') {
        # test arg from stack, if it's zero do nothing, otherwise overwrite it with a 1
        print "# unary not:\n";
        my $endlabel = label();
        print "pop x\n";
        print "test x\n";
        print "ld x, 0\n"; # doesn't clobber flags
        print "jnz $endlabel\n"; # if the popped value is not 0, then we want 0
        print "inc x\n"; # if the popped value was 0, then we want 1
        print "$endlabel:\n";
        print "push x\n";
    } elsif ($op eq '+') {
        # unary + is a no-op
    } elsif ($op eq '-') {
        # pop arg from stack, negate it, put it back on stack
        print "# unary arithmetic negation:\n";
        print "pop x\n";
        print "neg x\n";
        print "push x\n";
    } elsif ($op eq '*') {
        # pop arg from stack, dereference it, put it back on stack
        print "# pointer dereference:\n";
        print "pop x\n";
        print "ld x, (x)\n";
        print "push x\n";
    }

    return 1;
}

sub parseAddressOf {
    return 0 if !parseChar('&');
    skip();
    die "can't take address of anything other than an identifier" if !parseIdentifier();
    skip();

    my $id = pop @stack;
    die "expected identifier" if $id->{type} ne 'identifier';

    my $sym = symlookup($id->{name});
    if ($sym->{type} eq 'global') {
        print "# &$id->{name} (global)\n";
        print "ld x, _$id->{name}\n";
        print "push x\n";
    } else {
        print "# &$id->{name} (local)\n";
        die "todo: can't take address of a local\n";
    }
}

sub label {
    $labelnum++;
    return "l__$labelnum";
}

sub parseExpression {
    return parseExpressionLevel(0);
}

# while loop: pop 2 args off stack and apply expression
sub parseExpressionLevel {
    my ($level) = @_;

    my @operators = (
        #['*','/','%'],
        ['+','-'],
        ['&','|','^'],
        ['==','!=','>=','<=','>','<'],
        ['&&','||'],
    );

    my %mnemonic = (
        '+' => 'add',
        '-' => 'sub',
        '&' => 'and',
        '|' => 'or',
    );

    return parseTerm() if $level == @operators;

    my $pos0 = $pos;
    my $apply_op;
    while (1) {
        if (!parseExpressionLevel($level+1)) {
            $pos = $pos0;
            return 0;
        }
        skip();

        # TODO: if not first loop, generate code to pop 2 args and apply $last_op
        if ($apply_op) {
            print "# $apply_op\n";
            print "pop x\n";
            print "ld r0, x\n";
            print "pop x\n";

            if ($apply_op =~ /^[-+&|]$/) {
                print "$mnemonic{$apply_op} x, r0\n";

            } elsif ($apply_op eq '!=') {
                my $end = label();
                print "sub x, r0\n";
                # now x == 0 if args are equal
                print "jz $end\n";
                print "ld x, 1\n";
                print "$end:\n";

            } elsif ($apply_op eq '==') {
                my $end = label();
                print "sub x, r0\n";
                # now x == 0 if args are equal
                print "ld x, 0\n"; # doesn't clobber flags
                print "jnz $end\n"; # if the operands are not equal, then we want 0
                print "inc x\n";
                print "$end:\n";

            } elsif ($apply_op eq '>=') {
                # subtract 2nd argument from first, if result is less than zero, then 2nd argument is bigger than first
                # XXX: dubious? (what about integer overflow)
                my $lt = label();
                my $end = label();
                print "sub x, r0\n";
                print "jlt $lt\n";
                print "ld x, 1\n";
                print "jmp $end\n";
                print "$lt: ld x, 0\n";
                print "$end:\n"

            } else {
                print " # TODO: apply $apply_op to x and r0\n";
            }

            print "push x\n";
        }

        my $ok = 0;
        for my $op (@{ $operators[$level] }) {
            if (parseString($op)) {
                $apply_op = $op;
                $ok = 1;
                last;
            }
        }
        return 1 if !$ok;
        skip();
    }
}

sub parseTerm {
    return 1 if parseConstant() || parseFunctionCall() || parseAddressOf() || parseUnaryExpression() || parseParenExpression();

    return 0 if !parseIdentifier();
    my $id = pop @stack;
    die "expected identifier" if $id->{type} ne 'identifier';

    pushvar($id->{name});

    return 1;
}

sub poptovar {
    my ($name) = @_;

    my $sym = symlookup($name);
    die "unrecognised identifier: $name\n" if !$sym;
    if ($sym->{type} eq 'global') {
        print "# poptovar: global $name\n";
        print "pop x\n";
        print "ld (_$name), x\n";
    } else {
        print "# poptovar: local $name ($sym->{bp_rel})\n";
        print "ld r252, r253\n";
        print "add r252, " . (($sym->{bp_rel}+0x10000)%0x10000) . "\n";
        print "pop x\n";
        print "ld (r252), x\n";
    }
}

sub pushvar {
    my ($name) = @_;

    # look up the identifier and push it
    my $sym = symlookup($name);
    die "unrecognised identifier: $name\n" if !$sym;
    if ($sym->{type} eq 'global') {
        print "# pushvar: global $name\n";
        print "ld x, (_$name)\n";
        print "push x\n";
    } else {
        print "# pushvar: local $name ($sym->{bp_rel})\n";
        print "ld x, r253\n";
        print "add x, " . (($sym->{bp_rel}+0x10000)%0x10000) . "\n";
        print "ld x, (x)\n";
        print "push x\n";
    }
}

sub parseParenExpression {
    my $pos0 = $pos;
    return 0 if !parseChar('(');
    skip();
    return 1 if parseExpression() && skip() && parseChar(')') && skip();
    $pos = $pos0;
    return 0;
}

sub parseIdentifier {
    my $pos0 = $pos;
    return 0 if !matchChar(qr/[a-zA-Z_]/);
    while (matchChar(qr/[a-zA-Z0-9_]/)) {};
    push @stack, {
        type => 'identifier',
        name => substr($s, $pos0, $pos-$pos0),
    };
    skip();
    return 1;
}

sub parseString {
    my ($s) = @_;
    my $pos0 = $pos;
    for my $c (split //, $s) {
        if (!parseChar($c)) {
            $pos = $pos0;
            return 0;
        }
    }
    return 1;
}

sub parseChar {
    my ($c) = @_;
    return matchChar(qr/\Q$c\E/);
}

sub matchChar {
    my ($re) = @_;
    return 0 if $pos >= @s;
    return 0 if $s[$pos] !~ /$re/;
    if ($s[$pos] eq "\n") {
        $line++;
        $col = 0;
    }
    $pos++;
    $col++;
    return 1;
}

# skip over whitespace and comments
sub skip {
    while (1) {
        if (parseChar('#')) {
            while (matchChar(qr/[^\n]/)) { } # skip everything until \n
        } elsif (!matchChar(qr/[ \t\r\n]/)) {
            return 1;
        }
    }
}
