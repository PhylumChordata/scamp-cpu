#!/usr/bin/perl

# TODO: would be good to load instructions.json and show some specific
#       instruction-related information
# TODO: we probably want the emulator to write the address that the instruction
#       register was last loaded from, rather than the literal current PC

use strict;
use warnings;

use List::Util qw(max);
use POSIX qw(strftime);
use Getopt::Long;

sub usage {
    my ($rc) = @_;
    print qq{usage: profhtml [options] < PROF > HTML

Read a profile file generated by the SCAMP emulator and write an HTML document
describing it.

options:
    -x,--anhex FILE  Set the annotated hex file describing the program
    -h,--help        Show this text

If --anhex is used then there will be more useful information available.
Annotated hex files are produced by the assembler with --verbose.
};
    exit($rc);
}

my $anhex;

GetOptions(
    'h|help' => sub { usage(0) },
    'x|anhex=s' => \$anhex,
) or usage(1);

my $l = <>;
die "don't recognise profile\n" if $l ne "scamp-profile\n";
my $endtime = readval('endtime');
my $cmdline = readval('cmdline');
my $cycles = readval('cycles');
my $elapsed_us = readval('elapsed_us');
my @pc_cycles = readarray('pc_cycles', 65536);
my @last_instr = readarray('last_instr', 65536);
my @opcode_cycles = readarray('opcode_cycles', 256);
my @addr_reads = readarray('addr_reads', 65536);
my @addr_writes = readarray('addr_writes', 65536);
my @SYMBOL;

read_anhex($anhex) if $anhex;

my $endtimestr = strftime("%Y-%m-%d %H:%M:%S", localtime($endtime));
my $nowtimestr = strftime("%Y-%m-%d %H:%M:%S", localtime(time));

print header();
print "Page generated: <b>$nowtimestr</b><br>\n";
print "Profiling completed: <b>$endtimestr</b><br>\n";
print "Command line: <b><tt>$cmdline</tt></b><br>\n";
print "Total cycles: <b>$cycles</b><br>\n";
print "Elapsed time: " . fmt_secs($elapsed_us/1000000) . "<br>\n";
print "Implied clock frequency: <b>" . sprintf("%.03f", $cycles / $elapsed_us) . " </b> MHz<br>\n";
print "Time at 1 MHz: " . fmt_secs($cycles/1000000) . "<br>\n";
print "<h2>Cycles per address</h2>\n";
pc_cycles();
print "<h2>Cycles per symbol</h2>\n";
symbol_cycles();
print "<h2>Cycles per opcode</h2>\n";
opcode_cycles();
print "<h2>Reads per address <small>(excl. pseudoregs)</small></h2>\n";
addr_reads();
print "<h2>Writes per address <small>(excl. pseudoregs)</small></h2>\n";
addr_writes();
print footer();

sub header {
    qq{<html>
<head>
<title>SCAMP Profiling</title>
<style type="text/css">
body {
    font-family: sans-serif;
}
h2 small {
    font-size: 0.5em;
}
table {
    border-spacing: 0px;
    border-collapse: collapse;
}
th, tr {
    border: solid 1px #ccc;
}
table.pc td {
    padding: 0;
    margin: 0;
    min-width: 4.5px;
    border: none;
}
table.pc th {
    font-size: 0.7em;
    font-family: monospace;
}
.right {
    text-align: right;
}
table.sym td {
    border: solid 1px #ccc;
    padding: 2px;
};
table.opcode td {
    min-width: 40px;
}
table.opcode th {
    font-family: monospace;
}
td:hover div.popup {
    display: block;
}
td div.popup {
    display: none;
}
td:hover {
    outline: solid 1px black !important;
}
div.popup {
    font-family: monospace;
    pointer-events: none;
    position: absolute;
    border: none;
    margin: none;
    padding: none;
    width: 200px;
}
</style>
</head>
<body>
<h1>SCAMP Profiling</h1>
};
}

sub pc_cycles {
    my $max_cycles = max(@pc_cycles);

    my $max_addr = max grep { $pc_cycles[$_] } (0..65535);

    print "<table class=\"pc\">\n";
    for my $y (0 .. ($max_addr>>8)) {
        print "<tr><th>" . sprintf("%04x", $y<<8) . "</th>";
        for my $x (0 .. 255) {
            my $addr = $y<<8 | $x;

            my $popuphtml = "<br>Address: ".sprintf("<b>%04x</b>",$addr)."<br>";
            $popuphtml .= "Cycles: <b>$pc_cycles[$addr] " . sprintf("(%.01f%% max)", 100*$pc_cycles[$addr]/$max_cycles) . "</b><br>";
            $popuphtml .= "Instruction: <b>" . ($pc_cycles[$addr] ? sprintf("%04x",$last_instr[$addr]) : "-") . "</b><br>";
            $popuphtml .= "Symbol: <b>$SYMBOL[$addr]</b><br>" if $SYMBOL[$addr];

            print "<td style=\"background-color:" . heatcolour($pc_cycles[$addr], $max_cycles, 1.0) . "\"><div class=\"popup\" style=\"background-color:" . heatcolour($pc_cycles[$addr], $max_cycles, 0.4) . "\">$popuphtml</div></td>";
        }
        print "</tr>\n";
    }
    print "</table>\n";
}

sub symbol_cycles {
    my %symcycles;
    for my $addr (0..65535) {
        $symcycles{$SYMBOL[$addr]} += $pc_cycles[$addr] if $SYMBOL[$addr];
    }
    print "<table class=\"sym\">\n";
    print "<tr><th>Symbol</th><th>Cycles</th><th>% total</th></tr>\n";
    my @syms = sort { $symcycles{$b} <=> $symcycles{$a} } keys %symcycles;
    for my $s (@syms) {
        print "<tr><td class=\"right\"><tt>$s</tt></td><td><b>$symcycles{$s}</b></td><td>". sprintf("%.2f%%", 100*$symcycles{$s}/$cycles) ."</td></tr>\n" if $symcycles{$s} > 0.001 * $cycles;
    }
    print "</table>\n";
}

sub opcode_cycles {
    my $max_cycles = max(@opcode_cycles);

    print "<table class=\"opcode\">\n";
    print "<tr><th></th>";
    print sprintf("<th>_%x</th>", $_) for (0..15);
    print "</tr>\n";
    for my $y (0 .. 15) {
        print "<tr><th>" . sprintf("%01x_", $y) . "</th>";
        for my $x (0 .. 15) {
            my $op = $y<<4 | $x;

            my $popuphtml = "<br>Opcode: ".sprintf("<b>%02x</b>",$op)."<br>";
            $popuphtml .= "Cycles: <b>$opcode_cycles[$op] " . sprintf("(%.01f%% max)", 100*$opcode_cycles[$op]/$max_cycles) . "</b><br>";

            print "<td style=\"background-color:" . heatcolour($opcode_cycles[$op], $max_cycles, 1.0) . "\"><div class=\"popup\" style=\"background-color:" . heatcolour($opcode_cycles[$op], $max_cycles, 0.4) . "\">$popuphtml</div></td>";
        }
        print "</tr>\n";
    }
    print "</table>\n";

}

# up to 0xfeff to exclude pseudo-registers
sub addr_reads {
    my $max_cycles = max(@addr_reads[0 .. 0xfeff]);

    my $max_addr = max grep { $addr_reads[$_] } (0 .. 0xfeff);

    print "<table class=\"pc\">\n";
    for my $y (0 .. ($max_addr>>8)) {
        print "<tr><th>" . sprintf("%04x", $y<<8) . "</th>";
        for my $x (0 .. 255) {
            my $addr = $y<<8 | $x;

            my $popuphtml = "<br>Address: ".sprintf("<b>%04x</b>",$addr)."<br>";
            $popuphtml .= "Reads: <b>$addr_reads[$addr] " . sprintf("(%.01f%% max)", 100*$addr_reads[$addr]/$max_cycles) . "</b><br>";
            $popuphtml .= "Symbol: <b>$SYMBOL[$addr]</b><br>" if $SYMBOL[$addr];

            print "<td style=\"background-color:" . heatcolour($addr_reads[$addr], $max_cycles, 1.0) . "\"><div class=\"popup\" style=\"background-color:" . heatcolour($addr_reads[$addr], $max_cycles, 0.4) . "\">$popuphtml</div></td>";
        }
        print "</tr>\n";
    }
    print "</table>\n";
}

# up to 0xfeff to exclude pseudo-registers
sub addr_writes {
    my $max_cycles = max(@addr_writes[0 .. 0xfeff]);

    my $max_addr = max grep { $addr_writes[$_] } (0 .. 0xfeff);

    print "<table class=\"pc\">\n";
    for my $y (0 .. ($max_addr>>8)) {
        print "<tr><th>" . sprintf("%04x", $y<<8) . "</th>";
        for my $x (0 .. 255) {
            my $addr = $y<<8 | $x;

            my $popuphtml = "<br>Address: ".sprintf("<b>%04x</b>",$addr)."<br>";
            $popuphtml .= "Writes: <b>$addr_writes[$addr] " . sprintf("(%.01f%% max)", 100*$addr_writes[$addr]/$max_cycles) . "</b><br>";
            $popuphtml .= "Symbol: <b>$SYMBOL[$addr]</b><br>" if $SYMBOL[$addr];

            print "<td style=\"background-color:" . heatcolour($addr_writes[$addr], $max_cycles, 1.0) . "\"><div class=\"popup\" style=\"background-color:" . heatcolour($addr_writes[$addr], $max_cycles, 0.4) . "\">$popuphtml</div></td>";
        }
        print "</tr>\n";
    }
    print "</table>\n";
}

sub footer {
    qq{</body>
</html>
};
}

sub fmt_secs {
    my ($secs) = @_;

    my $hrs = 0;
    my $mins = 0;

    if ($secs > 60) {
        $mins = int($secs/60);
        $secs = $secs%60;
    }
    if ($mins > 60) {
        $hrs = int($mins/60);
        $mins = $mins%60;
    }

    return sprintf("<b>%d</b>h<b>%02d</b>m", $hrs, $mins) if $hrs > 0;
    return sprintf("<b>%d</b>m<b>%02d</b>s", $mins, $secs) if $mins > 0;
    return sprintf("<b>%02.3f</b>s", $secs);
}

sub heatcolour {
    my ($v, $max, $opacity) = @_;

    return "rgba(255,255,255,$opacity)" if $v == 0;

    my @cold = (227,231,239);
    my @hot = (255,0,0);

    my $k = $v / $max;

    my @col = map { $cold[$_]+($hot[$_]-$cold[$_])*$k } 0..2;
    return 'rgba(' . join(',',@col,$opacity) . ')';
}

sub readval {
    my ($key) = @_;
    my $line = <>;
    chomp $line;
    die "line $.: expected $key: $line\n" if $line !~ /^$key: (.*)$/;
    return $1;
}

sub readarray {
    my ($key, $len) = @_;
    my $line = <>;
    chomp $line;
    die "line $.: expected $key: $line\n" if $line !~ /^$key:$/;
    my @vals;
    for (1..$len) {
        my $l = <>;
        chomp $l;
        die "line $.: expected numeric: $l\n", if $l !~ /^\d+$/;
        push @vals, $l;
    }
    return @vals;
}

sub read_anhex {
    my ($file) = @_;

    my $addr = 0;
    my $lastaddr;
    my $sym;

    @SYMBOL = (undef)x65536;

    open (my $fh, '<', $file)
        or die "can't read $file: $!\n";
    while (<$fh>) {
        chomp;
        $addr=hex($1) if /^([0-9a-f]+):/;

        $sym = $1 if /#sym:(\w+)/;
        $sym = undef if /#nosym/;
        $sym = $1 if /# (\w+): \.word 0/;

        if ($sym) {
            $SYMBOL[$_] = $sym for ($lastaddr+1..$addr);
        }
        $lastaddr = $addr;
    }
    close $fh;
}
