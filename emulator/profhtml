#!/usr/bin/perl

# TODO: would be good to load instructions.json and show some specific
#       instruction-related information
# TODO: we probably want the emulator to write the address that the instruction
#       register was last loaded from, rather than the literal current PC

use strict;
use warnings;

use List::Util qw(max);
use POSIX qw(strftime);

my $l = <>;
die "don't recognise profile\n" if $l ne "scamp-profile\n";
my $endtime = readval('endtime');
my $cmdline = readval('cmdline');
my $cycles = readval('cycles');
my $elapsed_us = readval('elapsed_us');
my @pc_cycles = readarray('pc_cycles', 65536);
my @last_instr = readarray('last_instr', 65536);
my @opcode_cycles = readarray('opcode_cycles', 256);

my $endtimestr = strftime("%Y-%m-%d %H:%M:%S", localtime($endtime));
my $nowtimestr = strftime("%Y-%m-%d %H:%M:%S", localtime(time));

print header();
print "Page generated: <b>$nowtimestr</b><br>\n";
print "Profiling completed: <b>$endtimestr</b><br>\n";
print "Command line: <b><tt>$cmdline</tt></b><br>\n";
print "Total cycles: <b>$cycles</b><br>\n";
print "Elapsed time: <b>" . sprintf("%.03f", $elapsed_us/1000000) . "</b> secs<br>\n";
print "Time at 1 MHz: <b>" . sprintf("%.03f", $cycles/1000000) . "</b> secs<br>\n";
print "<h2>Cycles per address</h2>\n";
pc_cycles();
print "<h2>Cycles per opcode</h2>\n";
opcode_cycles();
print footer();

sub header {
    qq{<html>
<head>
<title>SCAMP Profiling</title>
<style type="text/css">
table {
    border: none;
    border-spacing: 0px;
}
table.pc td {
    padding: 0;
    margin: 0;
    min-width: 4.5px;
    border: none;
}
table.pc th {
    font-size: 0.7em;
    font-family: monospace;
}
table.opcode td {
    min-width: 40px;
}
table.opcode th {
    font-family: monospace;
}
td:hover div.popup {
    display: block;
}
td div.popup {
    display: none;
}
td:hover {
    outline: solid 1px black !important;
}
div.popup {
    font-family: monospace;
    pointer-events: none;
    position: absolute;
    border: none;
    margin: none;
    padding: none;
    width: 200px;
}
</style>
</head>
<body>
<h1>SCAMP Profiling</h1>
};
}

sub pc_cycles {
    my $max_cycles = max(@pc_cycles);

    my $max_addr = max grep { $pc_cycles[$_] } (0..65535);

    print "<table class=\"pc\">\n";
    for my $y (0 .. ($max_addr>>8)) {
        print "<tr><th>" . sprintf("%04x", $y<<8) . "</th>";
        for my $x (0 .. 255) {
            my $addr = $y<<8 | $x;

            my $popuphtml = "<br>Address: ".sprintf("<b>%04x</b>",$addr)."<br>";
            $popuphtml .= "Cycles: <b>$pc_cycles[$addr] " . sprintf("(%.01f%% max)", 100*$pc_cycles[$addr]/$max_cycles) . "</b><br>";
            $popuphtml .= "Instruction: <b>" . ($pc_cycles[$addr] ? sprintf("%04x",$last_instr[$addr]) : "-") . "</b><br>";

            print "<td style=\"background-color:" . heatcolour($pc_cycles[$addr], $max_cycles, 1.0) . "\"><div class=\"popup\" style=\"background-color:" . heatcolour($pc_cycles[$addr], $max_cycles, 0.4) . "\">$popuphtml</div></td>";
        }
        print "</tr>\n";
    }
    print "</table>\n";
}

sub opcode_cycles {
    my $max_cycles = max(@opcode_cycles);

    print "<table class=\"opcode\">\n";
    print "<tr><th></th>";
    print sprintf("<th>_%x</th>", $_) for (0..15);
    print "</tr>\n";
    for my $y (0 .. 15) {
        print "<tr><th>" . sprintf("%01x_", $y) . "</th>";
        for my $x (0 .. 15) {
            my $op = $y<<4 | $x;

            my $popuphtml = "<br>Opcode: ".sprintf("<b>%02x</b>",$op)."<br>";
            $popuphtml .= "Cycles: <b>$opcode_cycles[$op] " . sprintf("(%.01f%% max)", 100*$opcode_cycles[$op]/$max_cycles) . "</b><br>";

            print "<td style=\"background-color:" . heatcolour($opcode_cycles[$op], $max_cycles, 1.0) . "\"><div class=\"popup\" style=\"background-color:" . heatcolour($opcode_cycles[$op], $max_cycles, 0.4) . "\">$popuphtml</div></td>";
        }
        print "</tr>\n";
    }
    print "</table>\n";

}

sub footer {
    qq{</body>
</html>
};
}

sub heatcolour {
    my ($v, $max, $opacity) = @_;

    return "rgba(255,255,255,$opacity)" if $v == 0;

    my @cold = (227,231,239);
    my @hot = (255,0,0);

    my $k = $v / $max;

    my @col = map { $cold[$_]+($hot[$_]-$cold[$_])*$k } 0..2;
    return 'rgba(' . join(',',@col,$opacity) . ')';
}

sub readval {
    my ($key) = @_;
    my $line = <>;
    chomp $line;
    die "line $.: expected $key: $line\n" if $line !~ /^$key: (.*)$/;
    return $1;
}

sub readarray {
    my ($key, $len) = @_;
    my $line = <>;
    chomp $line;
    die "line $.: expected $key: $line\n" if $line !~ /^$key:$/;
    my @vals;
    for (1..$len) {
        my $l = <>;
        chomp $l;
        die "line $.: expected numeric: $l\n", if $l !~ /^\d+$/;
        push @vals, $l;
    }
    return @vals;
}
