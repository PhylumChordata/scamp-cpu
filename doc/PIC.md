# Position-independent code

I think I want to implement `strace`, by having it rewrite all the system call
vectors so that they point to `strace`'s shims that output the arguments
to the console and then call the real system call.

So `strace ls` would:

1. copy the shims into the top of memory so that they don't get overwritten by
the child process
2. overwrite system call vectors so that they point to the shims
3. `system("ls")`
4. when `ls` makes any system calls, the shims will output them to the console
5. when `ls` exits, undo the shims and set `osbase()` back to what it was before

Step 1 is the tricky one: if we copy the shims right below the start
of the kernel, then all the addresses in the code depend on where the kernel starts.
One solution is to hardcode the start address of the shims, but this means they
need to be recompiled every time the kernel gets larger.

Another solution is to make the shims position-independent. I think that's totally
feasible so I want to do it.

## Working out where you are

Just call any system call and look in `r254` after it returns:

    call (0xfeed) # call osbase()
    # r254 now contains the address of the next instruction

Even in the absence of the kernel, you can work out where your code is by creating a
`ret` instruction, calling it, and then looking in `r254` after control is returned:

    ld (0xff00), 0xf400 # create a "ret" instruction into r0
    call 0xff00         # call the "ret" instruction
    # r254 now contains the address of the next instruction

This is mildly unpleasant because it requires hard-coding the opcode for `ret`,
and that occasionally changes if I rearrange the instruction table, but it'll
do for now. Maybe we could have some support in the assembler so we can refer to it
as `RET_OPCODE` or something.

## Relative address accesses

Working out where you are in memory is one thing, but after that all memory accesses
need to be relative to this base address, which we don't have any CPU support for.

Options include:

1. Keep a list of all addresses and patch them one-by-one so that they now point
to the correct place. This sounds hairy but I think isn't *too* bad, other than
that the assembler doesn't have any way to make it easy for us. Probably we'd
have some other program generate the code, which would take care of remembering all
the addresses that need patching.

2. Store the offset at some fixed address and make all access relative to that.
The obvious candidates for fixed addresses are the pseudoregisters, but these
can be clobbered by function calls. So maybe you'd designate (say) `r1` to hold
the base address, and push `r1` before every function call and pop it after?
This seems strictly worse than patching the addresses because it comes with a
performance hit on every access & every function call, and makes the code more
annoying to write.

## Patching addresses

I think we'd assemble the code with the assumption that it starts at 0xfffe, so
that when the (2-word) `call` instruction returns, the base address is relative to 0.
Something like:

    .at 0xfffe
    .def osbase (0xfeed)
    call osbase
    # we now have the base address offset in r254 and osbase() address in r0

    # find the address of the list of addresses to patch
    ld r2, patch_addrs
    add r2, r254

    # add r254 to each word that needs patching
    patch_loop:
        add (r2), r254
        inc r2
        test (r2)
        jnz patch_loop

    [... rest of code goes here, without regard for position-independence ...]

    patch_addrs:
        # this is a zero-terminated list of addresses that need to have the
        # base address added - it should be generated by the "assembler" rather
        # than hand-maintained
        .word 0x000a
        .word 0x000f
        .word 0x0013
        .word 0x0016
        [...]
        .word 0
