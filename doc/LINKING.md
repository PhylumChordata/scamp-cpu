# Linking

To reduce compile times within **SCAMP/os**, the library files are pre-compiled
into an object file stored at `/lib/lib.o`. There isn't a proper linker, there are
just a series of small bodges that make this work.

It helps if you understand how SLANG programs are "meant" to be compiled:

1. `slangc` turns the SLANG source into assembly code.
2. `include` statements just include the referenced files directly in the program.
3. the generated assembly code is combined with `head.s` at the start (mainly to initialise
   the stack pointer) and `foot.s` at the end (mainly to `exit(0)`), and turned into
   an executable by `asm`.

This is not acceptable because the vast majority of the compilation (and assembly)
time is spent re-compiling the exact same code from the libraries each time. The
solution is to create a blob that contains the generated executable code for the
library functions, and just include this blob instead of re-compiling the libraries
every time.

Turning library code into a static pre-compiled blob was the biggest contributor to
reducing compilation time of "Hello, world" from 27 minutes to 2 minutes at 1 MHz.

## Creating `lib.o`

See `sys/make-lib` for the script that creates `lib.o`. In short:

1. Create a SLANG source file that includes every library you want in the blob, something like:

   ```
    include "malloc.sl";
    include "stdio.sl";
    include "stdlib.sl";
    # ...
   ```

2. Turn this source into assembly code with `slangc`.

3. Using a hacked `head.s` (see `sys/lib/libhead.s` - we need it to skip the code
   that initialises the stack pointer, but still retain definitions of system call
   vectors), turn the assembly code into machine code. This output is `lib.o`.

4. At the same time, get `asm` to generate a `lib.s` assembly source file that defines
   all of the symbols. This is the `--asm-header` option. (It actually only writes
   symbols that begin with an underscore, as these are the only ones accessible from
   SLANG). This looks like:

   ```
    # ...
    .def _printf 0x209f
    .def _putchar 0x2098
    .def _puts 0x209c
    .def _read 0x2080
    .def _readdir 0x2078
    # ...
   ```

    This has `.blob /lib/lib.o` prepended to it by `make-lib` so that when it is assembled,
    the library blob is included.

5. At the same time, get `asm` to generate a `lib.h` SLANG source file that *names*
   the same symbols, so that `slangc` knows they're available. This looks like:

   ```
    # ...
    extern printf;
    extern putchar;
    extern puts;
    extern read;
    extern readdir;
    # ...
   ```

6. Now when we compile a SLANG program, if we include `lib.h` instead of the SLANG source for
   each library, and we make sure `lib.s` is included in the assembly code, then we'll get
   access to all of the library functions without having to recompile them. Great success.

## Tricky bits

To make sure that unmodified programs can use either the pre-compiled library (such as within SCAMP/os),
or directly use the source code of the libraries (such as when cross-compiling), we say that
the convention is that the program should always include the libraries it wants (i.e.
`include "stdio.sl"`, *not* `include "lib.h"`), but the contents of `/lib/stdio.sl`
in SCAMP/os is just `include "lib.h"`.

Some parts of the library (namely `malloc()` and `system()`) need to know the highest address used
by the program (called `TOP`). Previously, this was provided by `foot.s`. The initial value of `TOP` can
not be known at the time the library is compiled, because it depends on how large the eventual
program is. For this reason, `libhead.s` contains a `.def` directive that points at the address of
the `_TOP` symbol, which is now defined in `head.s` so that it has a fixed address.

There is some code in `head.s` that needs to run before the start of the library. It needs to initialise the
stack pointer and the value of `_TOP`. Both of these need to know where the program code ends, which
means they can't be pre-compiled. For this reason, `libhead.s` starts with `.at 0x10a` instead of `.at
0x100`, to leave room for the instructions generated by `head.s`. This is kind of confusing and error-prone,
but it works.

This "pre-compiled blob" strategy works for as many libraries as you want, but you need all libraries to
be compiler into a single blob. I can't think of a way to mix and match multiple blobs, because all of
the addresses are static. To mix-and-match different blobs, we'd need to defer the `resolve_unbounds()`
step of `asm` to the final compilation step, which would basically be what a proper linker would
do. Maybe one day I'll do a proper linker.
